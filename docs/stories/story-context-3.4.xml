<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.4</storyId>
    <title>Template CRUD API Endpoints</title>
    <status>Ready</status>
    <generatedAt>2025-10-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-3.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>complete API endpoints for template management with proper authentication and security</iWant>
    <soThat>the frontend can save, load, update, and delete templates securely with user isolation</soThat>
    <tasks>
      - Task 1: Database Schema Migration - Epic 1 to Epic 3 (11 subtasks - BREAKING CHANGE)
      - Task 1.5: Server-Side Supabase Client with Authentication (3 subtasks)
      - Task 2: Zod Validation Schemas (7 subtasks)
      - Task 3: GET /api/templates - List Templates (10 subtasks)
      - Task 4: POST /api/templates - Create Template (12 subtasks)
      - Task 5: GET /api/templates/:id - Get Single Template (9 subtasks)
      - Task 6: PUT /api/templates/:id - Update Template (8 subtasks)
      - Task 7: DELETE /api/templates/:id - Delete Template (6 subtasks)
      - Task 8: Error Handling and HTTP Status Codes (8 subtasks)
      - Task 9: RLS Policy Verification (7 subtasks)
      - Task 10: Unit Tests (12 subtasks)
      - Task 11: Integration with Existing Frontend (5 subtasks)
      - Task 12: Testing and Validation (7 subtasks)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. GET /api/templates - List user's templates (with RLS)
    2. POST /api/templates - Create template (body: name, fields, extraction_prompt)
    3. GET /api/templates/:id - Get single template
    4. PUT /api/templates/:id - Update template
    5. DELETE /api/templates/:id - Delete template
    6. Zod schemas for validation
    7. Database schema migrated from Epic 1 (3 tables) to Epic 3 (1 table with JSONB) with backup/rollback strategy
    8. RLS policies enforce user_id isolation with auth.uid() validation
    9. Error handling: 400 for validation, 401 for unauthorized, 404 for not found, 500 for server errors
    10. Unit tests for all endpoints
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- Product Requirements Document -->
      <doc>
        <path>docs/PRD.md</path>
        <title>MMDocScan Product Requirements Document</title>
        <section>Template Management Requirements</section>
        <snippet>FR001-FR007: System shall provide template management including UI-based builder, AI-generated field suggestions, field definitions with data types, custom AI prompts, template storage/retrieval, and support for 6 template types (Invoices, Estimates, Equipment Logs, Timesheets, Consumable Logs, Generic Documents)</snippet>
      </doc>

      <!-- Epic 3 Technical Specification -->
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Unified Batch Extraction Workflow</title>
        <section>Data Models and Contracts - Template Models</section>
        <snippet>Epic 3 template schema: Template { id, name, fields: TemplateField[], extraction_prompt, user_id, created_at, updated_at } with TemplateField { id, name, instructions?, order }. Note: Epic 3 uses denormalized single-table design with JSONB fields column vs Epic 1's normalized 3-table design</snippet>
      </doc>

      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Unified Batch Extraction Workflow</title>
        <section>Database Schemas - Templates Table</section>
        <snippet>CREATE TABLE templates (id UUID PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, name VARCHAR(100) NOT NULL, fields JSONB NOT NULL, extraction_prompt TEXT, created_at TIMESTAMPTZ, updated_at TIMESTAMPTZ, UNIQUE(user_id, name)). RLS policies: SELECT/INSERT/UPDATE/DELETE using auth.uid() = user_id</snippet>
      </doc>

      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Unified Batch Extraction Workflow</title>
        <section>APIs and Interfaces - Template APIs</section>
        <snippet>GET /api/templates (list user's templates with RLS), POST /api/templates (create with Zod validation: name 1-100 chars, min 1 field, prompt 0-2000 chars), PUT /api/templates/:id (update), DELETE /api/templates/:id (delete). All require authentication.</snippet>
      </doc>

      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Unified Batch Extraction Workflow</title>
        <section>Security - Authentication & Authorization</section>
        <snippet>Server-side authentication pattern: Use @supabase/ssr createServerClient (NOT anonymous client), import cookies from next/headers, call auth.getUser() at start of every API handler, return 401 if user is null BEFORE any database operations, RLS policies automatically filter queries by auth.uid() = user_id</snippet>
      </doc>

      <!-- Story 1.3 Reference (Epic 1 Schema) -->
      <doc>
        <path>docs/stories/story-1.3.md</path>
        <title>Story 1.3: Template Data Model and Storage</title>
        <section>Epic 1 Schema Implementation</section>
        <snippet>Epic 1 implemented normalized 3-table schema: templates (id, name, template_type, created_at, updated_at), template_fields (id, template_id, field_name, field_type, is_header, display_order), template_prompts (id, template_id, prompt_text, prompt_type). Story 3.4 requires migration to Epic 3's denormalized single-table schema.</snippet>
      </doc>

      <!-- Stories 3.2-3.3 Integration Context -->
      <doc>
        <path>docs/stories/story-3.2.md</path>
        <title>Story 3.2: Tag-Based Template Builder UI</title>
        <section>Frontend Consumer Context</section>
        <snippet>Frontend "Load existing" dropdown calls GET /api/templates to populate template list. "Save Template" button calls POST /api/templates (new) or PUT /api/templates/:id (existing). Template data structure matches Zustand store (ExtractionStore.fields array).</snippet>
      </doc>
    </docs>

    <code>
      <!-- Existing Supabase Client (Anonymous) -->
      <artifact>
        <path>lib/supabase.ts</path>
        <kind>client</kind>
        <symbol>supabase (anonymous client)</symbol>
        <lines>1-18</lines>
        <reason>MUST BE REPLACED: This is the anonymous Supabase client created with @supabase/supabase-js. Story 3.4 requires creating a NEW server-side client at lib/supabase-server.ts using @supabase/ssr createServerClient with cookies() from next/headers for auth context.</reason>
      </artifact>

      <!-- Existing API Route (Needs Migration) -->
      <artifact>
        <path>app/api/templates/route.ts</path>
        <kind>api-route</kind>
        <symbol>GET, POST handlers</symbol>
        <lines>1-112</lines>
        <reason>REQUIRES UPDATE: Current implementation uses Epic 1 schema (3 tables with template_type column). Must be updated to: 1) Import from lib/supabase-server.ts instead of lib/supabase.ts, 2) Add auth.getUser() validation returning 401 if null, 3) Update schema to Epic 3 (user_id, fields JSONB, extraction_prompt), 4) Remove template_type column, 5) Update Zod schemas for Epic 3 structure</reason>
      </artifact>

      <!-- Existing API Route (Needs Creation) -->
      <artifact>
        <path>app/api/templates/[id]/route.ts</path>
        <kind>api-route</kind>
        <symbol>GET, PUT, DELETE handlers</symbol>
        <lines>N/A</lines>
        <reason>TO BE CREATED: New file required for single-template operations (GET by id, PUT update, DELETE). Must use server-side client, auth.getUser() validation, RLS-aware queries (no manual WHERE user_id), and handle 404 for both non-existent templates and RLS-blocked access.</reason>
      </artifact>

      <!-- Type Definitions (Needs Migration) -->
      <artifact>
        <path>types/template.ts</path>
        <kind>types</kind>
        <symbol>Template, TemplateField, TemplatePrompt interfaces</symbol>
        <lines>1-162</lines>
        <reason>REQUIRES UPDATE: Current types match Epic 1 schema. Must be updated to Epic 3: Template interface should include user_id: string, remove template_type, change fields to TemplateField[] (array not separate table), add extraction_prompt: string. TemplateField should be simplified to { id, name, instructions?, order } (no template_id, field_type, is_header, display_order from Epic 1)</reason>
      </artifact>

      <!-- Epic 1 Migrations (Will Be Replaced) -->
      <artifact>
        <path>migrations/001_create_templates.sql</path>
        <kind>migration</kind>
        <symbol>templates table</symbol>
        <lines>1-42</lines>
        <reason>CONTEXT: Epic 1 schema baseline. Shows current templates table structure (id, name, template_type, created_at, updated_at) without user_id or fields JSONB. Migration 004 will transform this to Epic 3 schema.</reason>
      </artifact>

      <artifact>
        <path>migrations/002_create_template_fields.sql</path>
        <kind>migration</kind>
        <symbol>template_fields table</symbol>
        <lines>1-31</lines>
        <reason>TO BE DROPPED: Epic 1's normalized field storage. Migration 004 must migrate all rows to templates.fields JSONB array before dropping this table. Data transformation: { field_name, field_type, is_header, display_order } → { id, name, instructions, order }</reason>
      </artifact>

      <artifact>
        <path>migrations/003_create_template_prompts.sql</path>
        <kind>migration</kind>
        <symbol>template_prompts table</symbol>
        <lines>1-27</lines>
        <reason>TO BE DROPPED: Epic 1's prompt storage. Migration 004 must migrate prompt_text to templates.extraction_prompt TEXT before dropping this table. Only migrate 'extraction' type prompts; other types not in Epic 3 spec.</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="@supabase/supabase-js" version="^2.75.1">Anonymous client (existing)</package>
        <package name="@supabase/ssr" version="NOT INSTALLED">REQUIRED: Server-side client with auth context via cookies()</package>
        <package name="zod" version="^4.1.12">Request validation schemas</package>
        <package name="next" version="^14.2.0">App Router API routes</package>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>BREAKING CHANGE: Epic 1 to Epic 3 schema migration is destructive. Must backup all data before migration (backups/epic1_templates_backup_YYYYMMDD.json) and create rollback script (migrations/004_rollback_epic3_to_epic1.sql)</constraint>
    <constraint>Server-side authentication MANDATORY: All API routes must call auth.getUser() at start, return 401 if user is null BEFORE any database operations. Never use anonymous client for authenticated endpoints.</constraint>
    <constraint>RLS enforcement: All database queries automatically filtered by auth.uid() = user_id. No manual WHERE user_id clauses needed. 404 errors can mean either "not found" or "user doesn't own it" (indistinguishable by design for security)</constraint>
    <constraint>Validation requirements: Template name 1-100 chars (required), Fields array minimum 1 field (required), Field name 1-100 chars (required), Field instructions 0-500 chars (optional), Extraction prompt 0-2000 chars (optional)</constraint>
    <constraint>Error handling: 400 (validation errors, invalid UUIDs, duplicate names), 401 (missing/invalid authentication), 404 (template not found or RLS-blocked), 500 (database errors, unexpected failures). Generic error messages to client, detailed logs server-side.</constraint>
    <constraint>Database schema: UNIQUE(user_id, name) constraint prevents duplicate template names per user. ON DELETE CASCADE for user_id FK ensures cleanup on user deletion.</constraint>
    <constraint>Migration strategy: 1) Backup data, 2) Add user_id with backfill, 3) Migrate template_fields → fields JSONB, 4) Migrate template_prompts → extraction_prompt, 5) Create RLS policies, 6) Enable RLS, 7) Drop old tables, 8) Test rollback script</constraint>
    <constraint>Type safety: All API routes use Zod schemas for runtime validation. TypeScript interfaces must match Epic 3 database schema exactly.</constraint>
  </constraints>

  <interfaces>
    <!-- Template APIs -->
    <interface>
      <name>GET /api/templates</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/templates → { templates: Template[] }</signature>
      <path>app/api/templates/route.ts</path>
      <notes>Lists user's templates. RLS auto-filters by user_id. Requires authentication (401 if no user). Returns empty array if user has no templates.</notes>
    </interface>

    <interface>
      <name>POST /api/templates</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/templates { name, fields, extraction_prompt } → { template: Template }</signature>
      <path>app/api/templates/route.ts</path>
      <notes>Creates template. Validates with CreateTemplateSchema (Zod). RLS auto-adds user_id from auth.uid(). Returns 400 for validation errors or duplicate name (UNIQUE constraint). Returns 201 on success.</notes>
    </interface>

    <interface>
      <name>GET /api/templates/:id</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/templates/:id → { template: Template }</signature>
      <path>app/api/templates/[id]/route.ts</path>
      <notes>Gets single template by id. RLS auto-filters to user's templates. Returns 404 if not found OR user doesn't own it (security: don't reveal existence). Returns 400 for invalid UUID.</notes>
    </interface>

    <interface>
      <name>PUT /api/templates/:id</name>
      <kind>REST endpoint</kind>
      <signature>PUT /api/templates/:id { name?, fields?, extraction_prompt? } → { template: Template }</signature>
      <path>app/api/templates/[id]/route.ts</path>
      <notes>Updates template. Validates with UpdateTemplateSchema (all fields optional). RLS auto-filters to user's templates. Auto-updates updated_at via trigger. Returns 404 if not found or RLS-blocked.</notes>
    </interface>

    <interface>
      <name>DELETE /api/templates/:id</name>
      <kind>REST endpoint</kind>
      <signature>DELETE /api/templates/:id → { success: true, message: "Template deleted" }</signature>
      <path>app/api/templates/[id]/route.ts</path>
      <notes>Deletes template. RLS auto-filters to user's templates. Returns 404 if not found or RLS-blocked. Returns 200 with success message.</notes>
    </interface>

    <!-- Supabase Server Client -->
    <interface>
      <name>createClient (server-side)</name>
      <kind>function</kind>
      <signature>createClient() → SupabaseClient (with auth context)</signature>
      <path>lib/supabase-server.ts</path>
      <notes>TO BE CREATED: Server-side Supabase client factory. Uses @supabase/ssr createServerClient with cookies() from next/headers. Reads auth context from cookies. Used by all API routes for authenticated operations.</notes>
    </interface>

    <!-- Zod Validation Schemas -->
    <interface>
      <name>CreateTemplateSchema</name>
      <kind>Zod schema</kind>
      <signature>z.object({ name: z.string().min(1).max(100), fields: z.array(TemplateFieldSchema).min(1), extraction_prompt: z.string().max(2000).optional() })</signature>
      <path>lib/validation/templates.ts</path>
      <notes>TO BE CREATED: Validates POST /api/templates request body. TemplateFieldSchema: { name: z.string().min(1).max(100), instructions: z.string().max(500).optional(), order: z.number() }</notes>
    </interface>

    <interface>
      <name>UpdateTemplateSchema</name>
      <kind>Zod schema</kind>
      <signature>CreateTemplateSchema.partial()</signature>
      <path>lib/validation/templates.ts</path>
      <notes>TO BE CREATED: Validates PUT /api/templates/:id request body. All fields optional (partial update support).</notes>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Unit testing with Vitest framework. All API routes require unit tests with mocked Supabase server client and auth.getUser(). Test coverage: happy paths, validation errors, authentication failures (401), authorization failures (404 via RLS), duplicate name handling (400), database errors (500). Integration tests use MSW (Mock Service Worker) for API mocking. E2E tests with Playwright for critical flows (create template → save → load → update → delete).
    </standards>

    <locations>
      - tests/api/templates.test.ts (unit tests for all endpoints)
      - tests/integration/template-crud.test.ts (integration tests)
      - e2e/template-management.spec.ts (end-to-end tests)
    </locations>

    <ideas>
      <idea ac="1">Unit: Mock auth.getUser() returning test user, verify GET /api/templates returns filtered results. Test with user who has 0, 1, 5 templates.</idea>
      <idea ac="2">Unit: Test POST /api/templates with valid data (201), invalid data (400 validation errors), duplicate name (400), unauthenticated (401).</idea>
      <idea ac="3">Unit: Test GET /api/templates/:id returns template (200), returns 404 for non-existent id, returns 404 for another user's template (RLS).</idea>
      <idea ac="4">Unit: Test PUT /api/templates/:id updates name/fields/prompt, validates input (400), returns 404 for non-existent/RLS-blocked.</idea>
      <idea ac="5">Unit: Test DELETE /api/templates/:id deletes template (200), returns 404 for non-existent/RLS-blocked, verifies CASCADE delete if applicable.</idea>
      <idea ac="6">Unit: Test Zod schemas with edge cases: empty strings, max lengths exceeded, invalid types, missing required fields, optional fields null/undefined.</idea>
      <idea ac="7">Integration: Test complete migration flow: backup Epic 1 data → run migration 004 → verify Epic 3 schema → test rollback script restores Epic 1.</idea>
      <idea ac="8">Integration: Test RLS policies with multiple users: User A cannot access User B's templates via GET/PUT/DELETE (all return 404).</idea>
      <idea ac="9">E2E: Test error handling scenarios: 400 (validation), 401 (no auth), 404 (not found), 500 (mock database error), verify error response format.</idea>
      <idea ac="10">E2E: Run full test suite: Create template via POST → Load via GET list → Update via PUT → Fetch via GET by id → Delete via DELETE → Verify 404 on subsequent GET.</idea>
    </ideas>
  </tests>
</story-context>
